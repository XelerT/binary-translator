<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Binary Translator: Binary translator</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Binary Translator
   </div>
   <div id="projectbrief">Translate my binary to x86-IA.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Binary translator </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md1"></a>
Overview</h1>
<h1><a class="anchor" id="autotoc_md2"></a>
Introduction</h1>
<p>This work was made for studying processes of binary translation and JIT compilation.</p>
<p>Our binary translator is a tool to convert binary code for <a href="https://github.com/XelerT/cpu">my stack virtual cpu</a>. For creating programs for our cpu you can use our C-like <a href="https://github.com/XelerT/language">language</a>.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md4"></a>
Install &amp; Use</h1>
<p>Install and compile: </p><pre class="fragment">    $ git clone https://github.com/XelerT/binary-translator.git
    $ make
</pre><p> To compile with $int 3$ at the start of exec buffer for debugger: </p><pre class="fragment">    $ make run_debug
</pre><p> Run: </p><pre class="fragment">    $ ./jit bit_code.txt
</pre><p> Run tests: </p><pre class="fragment">    $ make test
</pre> <h1><a class="anchor" id="autotoc_md5"></a>
x86-64 encode</h1>
<p>We will tell you about some information with was used for creating commands auto encoding.</p>
<p>Command in x86-64 can consists of 5 parts (first line is size in bytes):</p>
<hr  />
<p> | 0 - 4 | 1 - 2 | 1 | 1 | 0 - 4 | </p>
<h1><a class="anchor" id="autotoc_md7"></a>
| Prefix | Opcode    | M.R.R/M  | S.I.B  | Data        |</h1>
<ul>
<li>Prefix part is used to encode 64 bit information, such as need to use 8 byte registers, need to use r8-r15 in source or destination.</li>
<li>In opcode command is encoded: (xxxxxx|ds). First 6 bits of this byte encode command, s-bit is 1 if we use 64-bit mode of command, d-bit contains information about source and destination: <pre class="fragment">  register  -&gt; memory   =&gt;      d = 0
  memory -&gt; register    =&gt;      d = 1
</pre></li>
<li>Mode-Register-Register/Memory (M.R.R/M): (xx|xxx|xxx). First 2 bits show which arguments has command, 11 - if 2 operands are registers, 00 - if destination is memory, 10 - if destination is register and source is immediate number.</li>
<li>Scale-Index-Base (S.I.B): (xx|xxx|xxx). First 2 bits indicates the scaling factor of index, next 3 bits is the index register to use, last three is the base register to use.</li>
<li>Data field can contain immediate number or address.</li>
</ul>
<h1><a class="anchor" id="autotoc_md8"></a>
Translation</h1>
<p>For technical details see [documentation](). </p>
<h2><a class="anchor" id="autotoc_md9"></a>
Parsing binary file</h2>
<p>During parsing process array of tokens is created. Each token contains information about each command: command encode for our cpu, (repeating x86 encode rules) mode, need of using r8-r15 registers etc. After this process simple IR is created.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Creation of executed buffer</h2>
<p>After parsing, array of tokens is translated in x86 commands. Each token is going through some layers of check, folding stack constructions into non-stack logic, for example: </p><pre class="fragment">    push 5
    push rax        =&gt;      add rax, 5
    add                           push rax
    ───────────────────────────────────────
    push 5
    pop rbx         =&gt;      mov rbx, 5
</pre><p> We obliged to save stack logic in order to avoid destruction of program logic therefor after math functions we push register into stack. </p><details >
<summary >
More encoding details.</summary>
<p></p>
<p></p>
<p>Jumps' and call's addresses are fulfilled using 2 step passage.</p>
<hr  />
<p> Our cpu have 2 stacks, the first is for working with numbers and the second contains returning addresses. For solving this problem we emulate our second stack. Register r15 is used as second rsp, at the beginning of buffer $mov r15, (end of data section address)$. Every call is changed for "push" in the second stack and jump to the address: </p><pre class="fragment">    mov qword [r15], (return address)
    sub r15, 8
    jmp (function)
</pre><p> Before return we need to "pop" return address: </p><pre class="fragment">    add r15, 8
    push qword [r15]
    ret
</pre> <hr  />
<p> For more details see [documentation]()</p>
<p></p>
</details>
<h2><a class="anchor" id="autotoc_md12"></a>
Execution</h2>
<p>After creation of execution buffer we change rights for "text section" and "data section" for execution, read, write using <a href="https://man7.org/linux/man-pages/man2/mprotect.2.html">mprotect</a>. Then we cast execution buffer pointer to function pointer and call this "function". </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
